# -*- coding: utf-8 -*-
"""Evidencia Situación problema Series Tiempo - Capital Analyst

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lYMt8c9sRtIY6PfdB59j7MibIa1FXrPy

# Evidencia Situación problema Series Tiempo - Capital Analyst
**Nombre:** Salva N.  
**Matrícula:** A0571848  
**Materia:** Series de Tiempo    
**Fecha:** Junio 2025
"""

# Librerías necesarias
import pandas as pd
import numpy as np
from google.colab import files
import statsmodels.api as sm
from statsmodels.tsa.stattools import adfuller, kpss
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.tsa.vector_ar.vecm import coint_johansen, VECM
import matplotlib.pyplot as plt
from itertools import combinations

plt.style.use('seaborn-v0_8-whitegrid')

# Acciones seleccionadas: McDonald's (MCD), John Deere (DE), Adobe Inc. (ADBE)
tickers = ['MCD', 'DE', 'ADBE']
data = {}
original_data = {}

# Subir archivos de precios (1 y 5 minutos por empresa)
for ticker in tickers:
    print(f"\n🔼 Sube los archivos de precios para: {ticker}")
    # Subir archivo de 1 minuto
    print(f"Sube el archivo de {ticker} a 1 minuto (1 columna 'Close')")
    uploaded_1min = files.upload()
    filename_1min = list(uploaded_1min.keys())[0]
    df_1min = pd.read_excel(filename_1min, usecols=['Close'])
    if df_1min.shape[1] != 1:
        raise ValueError(f"⚠️ El archivo 1min para {ticker} debe tener solo 'Close' como columna.")

    # Subir archivo de 5 minutos
    print(f"Sube el archivo de {ticker} a 5 minutos (1 columna 'Close')")
    uploaded_5min = files.upload()
    filename_5min = list(uploaded_5min.keys())[0]
    df_5min = pd.read_excel(filename_5min, usecols=['Close'])
    if df_5min.shape[1] != 1:
        raise ValueError(f"⚠️ El archivo 5min para {ticker} debe tener solo 'Close' como columna.")

    # Usar datos tal cual
    data[ticker] = {
        '1min': df_1min['Close'],
        '5min': df_5min['Close']
    }
    original_data[ticker] = data[ticker].copy()

    # Verificar mínimo 100 observaciones
    for freq in ['1min', '5min']:
        if len(data[ticker][freq]) < 100:
            print(f"⚠️ ADVERTENCIA: {ticker} ({freq}) tiene solo {len(data[ticker][freq])} observaciones. Se requiere mínimo 100.")

# Función para estacionariedad
def make_stationary(series, name, freq, max_d=1):
    current_series = series.copy()
    d = 0
    for _ in range(max_d):
        adf_result = adfuller(current_series)
        kpss_result = kpss(current_series, nlags="auto")
        print(f"\n🔍 ADF para {name} ({freq}, d={d}): p-value = {adf_result[1]:.4f}")
        print(f"🔍 KPSS para {name} ({freq}, d={d}): p-value = {kpss_result[1]:.4f}")
        if adf_result[1] < 0.05 and kpss_result[1] >= 0.05:
            print(f"✔️ {name} ({freq}) es estacionaria con d={d}")
            return current_series, d
        current_series = current_series.diff().dropna()
        d += 1
    print(f"⚠️ {name} ({freq}) no estacionaria tras {max_d} diferencias")
    return current_series, d

# Hacer series estacionarias
stationary_data = {}
d_values = {}
for ticker in tickers:
    stationary_data[ticker] = {}
    d_values[ticker] = {}
    for freq in ['1min', '5min']:
        stationary_data[ticker][freq], d_values[ticker][freq] = make_stationary(data[ticker][freq], ticker, freq)

# Correlogramas
for ticker in tickers:
    for freq in ['1min', '5min']:
        plt.figure(figsize=(14, 4))
        plt.subplot(1, 2, 1)
        plot_acf(stationary_data[ticker][freq], ax=plt.gca(), lags=36)
        plt.title(f"{ticker} ({freq}) - ACF")
        plt.subplot(1, 2, 2)
        plot_pacf(stationary_data[ticker][freq], ax=plt.gca(), lags=36, method='ywm')
        plt.title(f"{ticker} ({freq}) - PACF")
        plt.tight_layout()
        plt.show()

# Métricas de riesgo
for ticker in tickers:
    for freq in ['1min', '5min']:
        mean_return = data[ticker][freq].mean()
        std_dev = data[ticker][freq].std()
        print(f"\n📊 Métricas para {ticker} ({freq}):")
        print(f"Media: {mean_return:.4f}")
        print(f"Desviación estándar: {std_dev:.4f}")
        print(f"Interpretación: Una desviación estándar de {std_dev:.4f} indica {['bajo', 'moderado', 'alto'][int(std_dev > 0.1) + int(std_dev > 0.5)]} riesgo.")

# Modelos AR y ARMA para cada serie
ar_models = {}
arma_models = {}
for ticker in tickers:
    ar_models[ticker] = {}
    arma_models[ticker] = {}
    for freq in ['1min', '5min']:
        # AR Model (p=1 como ejemplo, ajusta según ACF/PACF)
        print(f"\n📈 Ajustando AR para {ticker} ({freq})")
        ar_model = ARIMA(stationary_data[ticker][freq], order=(1, d_values[ticker][freq], 0)).fit()
        print(f"AR(1) AIC: {ar_model.aic:.2f}")
        ar_models[ticker][freq] = ar_model

        # ARMA Model (p=1, q=1 como ejemplo, ajusta según ACF/PACF)
        print(f"\n📈 Ajustando ARMA para {ticker} ({freq})")
        arma_model = ARIMA(stationary_data[ticker][freq], order=(1, d_values[ticker][freq], 1)).fit()
        print(f"ARMA(1,1) AIC: {arma_model.aic:.2f}")
        arma_models[ticker][freq] = arma_model

        # Comparación y justificación
        aic_ar = ar_model.aic
        aic_arma = arma_model.aic
        aic_arima = arima_models[ticker][freq].aic
        print(f"Comparación AIC - AR: {aic_ar:.2f}, ARMA: {aic_arma:.2f}, ARIMA: {aic_arima:.2f}")
        print(f"Justificación: Seleccioné ARIMA({arima_models[ticker][freq].model.order}) por tener el menor AIC ({aic_arima:.2f}), indicando mejor ajuste.")

# Pruebas de cointegración y VECM
print("\n🔍 Pruebas de Cointegración (Johansen) para todas las series")
# Combinar las series originales en un DataFrame para cointegración
combined_data = pd.DataFrame({
    'MCD_1min': original_data['MCD']['1min'],
    'DE_1min': original_data['DE']['1min'],
    'ADBE_1min': original_data['ADBE']['1min'],
    'MCD_5min': original_data['MCD']['5min'],
    'DE_5min': original_data['DE']['5min'],
    'ADBE_5min': original_data['ADBE']['5min']
}).dropna()

# Johansen test para cointegración
johansen_test = coint_johansen(combined_data, det_order=0, k_ar_diff=1)
print("Resultados de Johansen:")
print(f"Trace Statistic: {johansen_test.lr1}")
print(f"Critical Values (90%, 95%, 99%): {johansen_test.cvt}")
print(f"Max Eigen Statistic: {johansen_test.lr2}")
print(f"Critical Values (90%, 95%, 99%): {johansen_test.cvm}")
# Interpretación: Si los estadísticos superan los valores críticos al 95%, hay cointegración
num_cointegrating_vectors = (johansen_test.lr1 > johansen_test.cvt[:, 1]).sum()
print(f"Número de vectores de cointegración: {num_cointegrating_vectors}")

# VECM si hay cointegración
if num_cointegrating_vectors > 0:
    print("\n📈 Ajustando VECM debido a cointegración")
    vecm_model = VECM(combined_data, k_ar_diff=1, coint_rank=num_cointegrating_vectors).fit()
    print(f"VECM ajustado con {num_cointegrating_vectors} vectores de cointegración")
    print(vecm_model.summary())
else:
    print("No se detectó cointegración, VECM no aplicable.")

# ARIMA estacionario
def fit_arima_stationary(series, name, freq, d, max_p=3, max_q=3):
    print(f"\n📈 Ajustando ARIMA para {name} ({freq}, d={d})")
    best_aic = float('inf')
    best_order = None
    for p in range(max_p + 1):
        for q in range(max_q + 1):
            try:
                model = ARIMA(series, order=(p, d, q)).fit()
                if model.aic < best_aic:
                    best_aic = model.aic
                    best_order = (p, d, q)
            except:
                continue
    print(f"🏆 ARIMA({best_order}) con AIC={best_aic:.2f}")
    return ARIMA(series, order=best_order).fit()

arima_models = {}
for ticker in tickers:
    arima_models[ticker] = {}
    for freq in ['1min', '5min']:
        arima_models[ticker][freq] = fit_arima_stationary(stationary_data[ticker][freq], ticker, freq, d_values[ticker][freq])

# Pronóstico
forecast_steps = 10
for ticker in tickers:
    for freq in ['1min', '5min']:
        forecast = arima_models[ticker][freq].get_forecast(steps=forecast_steps)
        pred_diff = forecast.predicted_mean.values  # Asegurar que sea un array numpy
        ci_diff = forecast.conf_int().values  # Asegurar que sea un array numpy
        print(f"Debug - Longitud de pred_diff: {len(pred_diff)}, ci_diff: {len(ci_diff)}")
        if len(pred_diff) != forecast_steps or len(ci_diff) != forecast_steps:
            print(f"⚠️ Advertencia: Longitudes inesperadas para {ticker} ({freq}). Ajustando...")
            forecast_steps = min(len(pred_diff), len(ci_diff))
        last_value = original_data[ticker][freq].iloc[-1]
        # Reescalamiento corregido para continuidad
        pred = [last_value]
        cumulative_diff = 0
        # Usar tendencia reciente para el primer valor
        recent_trend = original_data[ticker][freq].iloc[-5:].pct_change().mean() * last_value if len(original_data[ticker][freq]) > 5 else 0
        first_pred = last_value + (pred_diff[0] if d_values[ticker][freq] == 0 else recent_trend)
        pred.append(first_pred)
        for i in range(1, len(pred_diff)):
            cumulative_diff += pred_diff[i]
            pred.append(pred[-1] + cumulative_diff)
        ci = [(last_value, last_value)]
        for i in range(len(ci_diff)):
            lower = pred[1] + (ci_diff[i, 0] if i == 0 else ci_diff[i, 0] - ci_diff[0, 0])
            upper = pred[1] + (ci_diff[i, 1] if i == 0 else ci_diff[i, 1] - ci_diff[0, 0])
            ci.append((lower, upper))
        ci = pd.DataFrame(ci[1:], columns=['lower', 'upper'])

        forecast_index = range(len(data[ticker][freq]), len(data[ticker][freq]) + forecast_steps)

        plt.figure(figsize=(12, 6))
        plt.plot(range(len(original_data[ticker][freq])), original_data[ticker][freq], label=f"{ticker} ({freq}) histórico")
        plt.plot(forecast_index, pred[1:forecast_steps+1], label='Pronóstico', color='red')
        plt.fill_between(forecast_index, ci['lower'], ci['upper'], alpha=0.3, color='pink')
        plt.title(f"{ticker} ({freq}) - Pronóstico {forecast_steps} días")
        plt.legend()
        plt.show()

        print(f"\n🔍 Pronóstico para {ticker} ({freq}):")
        print(f"Último valor: {last_value:.2f}")
        print(f"Media pronosticada: {np.mean(pred[1:forecast_steps+1]):.2f}")
        trend = "⬆️ Alza" if np.mean(pred[1:forecast_steps+1]) > last_value else "⬇️ Baja" if np.mean(pred[1:forecast_steps+1]) < last_value else "➡️ Estable"
        print(f"Tendencia: {trend}")
        print(f"Intervalo final: [{ci.iloc[-1, 0]:.2f}, {ci.iloc[-1, 1]:.2f}]")
        print(f"Interpretación: La tendencia {trend} sugiere ajustes en la estrategia de Capital Analyst.")

# Exportar resultados
results_df = pd.DataFrame({
    'Ticker': [t for t in tickers for _ in ['1min', '5min']],
    'Frequency': ['1min', '5min'] * len(tickers),
    'Mean': [data[t][f].mean() for t in tickers for f in ['1min', '5min']],
    'Std Dev': [data[t][f].std() for t in tickers for f in ['1min', '5min']],
    'ARIMA Order': [arima_models[t][f].model.order for t in tickers for f in ['1min', '5min']],
    'Trend': [trend for t in tickers for f in ['1min', '5min']]
})
results_df.to_excel('capital_analyst_results.xlsx')
files.download('capital_analyst_results.xlsx')

